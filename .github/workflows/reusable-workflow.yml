name: Reusable Workflow

on:
  workflow_call:
    inputs:
      stage:
        required: true
        type: string
    secrets:
      AWS_ACCESS_KEY_ID:
        required: false
      AWS_SECRET_ACCESS_KEY:
        required: false
      AWS_REGION:
        required: false
      AWS_ORG_MASTER_ACCOUNT_ID:
        required: false
      AWS_DEPLOY_ROLE_NAME:
        required: false
      PROD_AWS_BUCKET_NAME:
        required: false
      DEV_AWS_BUCKET_NAME:
        required: false
      PROD_AWS_BUCKET_KEY_NAME:
        required: false
      DEV_AWS_BUCKET_KEY_NAME:
        required: false
      ALL_ACC_AWS_BUCKET_KEY_NAME:
        required: false
      ALL_ACC_AWS_BUCKET_NAME:
        required: false

jobs:
  deploy:
    name: Deploy with Terraform
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: List project files
        run: ls -l ${{ github.workspace }}

      - name: Determine Deployment Mode
        run: |
          if [ "${{ inputs.stage }}" == "all-accounts" ]; then
            echo "DEPLOY_MODE=all-accounts" >> $GITHUB_ENV
          else
            echo "DEPLOY_MODE=${{ inputs.stage }}" >> $GITHUB_ENV
          fi

      - name: Determine S3 Bucket and Key (Dev/Prod)
        run: |
          if [ "${{ inputs.stage }}" == "all-accounts" ]; then
            echo "S3_BUCKET=${{ secrets.ALL_ACC_AWS_BUCKET_NAME }}" >> $GITHUB_ENV
            echo "S3_BUCKET_KEY=${{ secrets.ALL_ACC_AWS_BUCKET_KEY_NAME }}" >> $GITHUB_ENV
          elif [ "${{ inputs.stage }}" == "prod" ]; then
            echo "S3_BUCKET=${{ secrets.PROD_AWS_BUCKET_NAME }}" >> $GITHUB_ENV
            echo "S3_BUCKET_KEY=${{ secrets.PROD_AWS_BUCKET_KEY_NAME }}" >> $GITHUB_ENV
          else
            echo "S3_BUCKET=${{ secrets.DEV_AWS_BUCKET_NAME }}" >> $GITHUB_ENV
            echo "S3_BUCKET_KEY=${{ secrets.DEV_AWS_BUCKET_KEY_NAME }}" >> $GITHUB_ENV
          fi

      - name: Initialize Terraform
        run: |
          terraform init -backend-config="bucket=$S3_BUCKET" -backend-config="key=$S3_BUCKET_KEY"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}

      - name: Terraform Apply (Dev/Prod)
        if: env.DEPLOY_MODE != 'all-accounts'
        run: |
          terraform apply -auto-approve -var="stage=${{ inputs.stage }}" -var="s3_bucket=$S3_BUCKET" -var="s3_bucket_key=$S3_BUCKET_KEY"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}

      - name: Get AWS Account IDs
        if: env.DEPLOY_MODE == 'all-accounts'
        run: |
          ACCOUNT_IDS=$(aws organizations list-accounts --query "Accounts[*].Id" --output json | jq -r '.[]' | tr '\n' ',')
          ACCOUNT_IDS=${ACCOUNT_IDS%,}
          echo "ACCOUNT_IDS=$ACCOUNT_IDS" >> $GITHUB_ENV
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}

      - name: Assume Role and Deploy to Each Account
        if: env.DEPLOY_MODE == 'all-accounts'
        run: |
          set -e  # Exit immediately if any command fails

          # Step 1: Authenticate using the management account
          echo "Assuming role in the management account (${{ secrets.AWS_ORG_MASTER_ACCOUNT_ID }})"

          # Assume the role in the management account
          TEMP_ROLE_MANAGEMENT_ACCOUNT=$(aws sts assume-role --role-arn "arn:aws:iam::${{ secrets.AWS_ORG_MASTER_ACCOUNT_ID }}:role/${{ secrets.AWS_DEPLOY_ROLE_NAME }}" --role-session-name GitHubDeployment --duration-seconds 3600)

          # Extract temporary credentials for the management account
          export AWS_ACCESS_KEY_ID=$(echo $TEMP_ROLE_MANAGEMENT_ACCOUNT | jq -r '.Credentials.AccessKeyId')
          export AWS_SECRET_ACCESS_KEY=$(echo $TEMP_ROLE_MANAGEMENT_ACCOUNT | jq -r '.Credentials.SecretAccessKey')
          export AWS_SESSION_TOKEN=$(echo $TEMP_ROLE_MANAGEMENT_ACCOUNT | jq -r '.Credentials.SessionToken')

          # Validate credentials for the management account
          if [ -z "$AWS_ACCESS_KEY_ID" ] || [ -z "$AWS_SECRET_ACCESS_KEY" ] || [ -z "$AWS_SESSION_TOKEN" ]; then
            echo "Failed to assume role for the management account. Exiting."
            exit 1
          fi

          # Step 2: Assume roles in other accounts and deploy
          IFS=',' read -ra ACCOUNTS <<< "${{ env.ACCOUNT_IDS }}"
          for ACCOUNT_ID in "${ACCOUNTS[@]}"; do
            (
              echo "Deploying to Account: $ACCOUNT_ID"

              # Skip the management account
              if [ "$ACCOUNT_ID" == "${{ secrets.AWS_ORG_MASTER_ACCOUNT_ID }}" ]; then
                echo "Skipping management account $ACCOUNT_ID"
                exit 0
              fi

              # Check if the role exists in the target account
              ROLE_ARN="arn:aws:iam::$ACCOUNT_ID:role/${{ secrets.AWS_DEPLOY_ROLE_NAME }}"
              if ! aws iam get-role --role-name "${{ secrets.AWS_DEPLOY_ROLE_NAME }}" --output text > /dev/null 2>&1; then
                echo "Role ${{ secrets.AWS_DEPLOY_ROLE_NAME }} does not exist in account $ACCOUNT_ID. Skipping."
                exit 0
              fi

              # Assume the role in the target account
              TEMP_ROLE=$(aws sts assume-role --role-arn "$ROLE_ARN" --role-session-name GitHubDeployment --duration-seconds 3600)

              # Extract temporary credentials for the target account
              export TARGET_AWS_ACCESS_KEY_ID=$(echo $TEMP_ROLE | jq -r '.Credentials.AccessKeyId')
              export TARGET_AWS_SECRET_ACCESS_KEY=$(echo $TEMP_ROLE | jq -r '.Credentials.SecretAccessKey')
              export TARGET_AWS_SESSION_TOKEN=$(echo $TEMP_ROLE | jq -r '.Credentials.SessionToken')

              # Validate credentials for the target account
              if [ -z "$TARGET_AWS_ACCESS_KEY_ID" ] || [ -z "$TARGET_AWS_SECRET_ACCESS_KEY" ] || [ -z "$TARGET_AWS_SESSION_TOKEN" ]; then
                echo "Failed to assume role for account $ACCOUNT_ID. Skipping deployment."
                exit 0
              fi

              # Verify the caller identity for the target account
              echo "Caller identity for account $ACCOUNT_ID:"
              AWS_ACCESS_KEY_ID=$TARGET_AWS_ACCESS_KEY_ID \
              AWS_SECRET_ACCESS_KEY=$TARGET_AWS_SECRET_ACCESS_KEY \
              AWS_SESSION_TOKEN=$TARGET_AWS_SESSION_TOKEN \
              aws sts get-caller-identity

              # Navigate to the Terraform directory
              cd ${{ github.workspace }}

              # Run terraform plan and apply
              echo "Running terraform plan for account $ACCOUNT_ID"
              AWS_ACCESS_KEY_ID=$TARGET_AWS_ACCESS_KEY_ID \
              AWS_SECRET_ACCESS_KEY=$TARGET_AWS_SECRET_ACCESS_KEY \
              AWS_SESSION_TOKEN=$TARGET_AWS_SESSION_TOKEN \
              terraform plan -var-file="${{ github.workspace }}/all-account.tfvars"

              echo "Applying changes for account $ACCOUNT_ID"
              AWS_ACCESS_KEY_ID=$TARGET_AWS_ACCESS_KEY_ID \
              AWS_SECRET_ACCESS_KEY=$TARGET_AWS_SECRET_ACCESS_KEY \
              AWS_SESSION_TOKEN=$TARGET_AWS_SESSION_TOKEN \
              terraform apply -auto-approve -var-file="${{ github.workspace }}/all-account.tfvars"
            ) &
          done

          # Wait for all background processes to complete
          wait
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
